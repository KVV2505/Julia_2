#Написать функцию sortkey!(a, key_values), получающую на вход некоторый вектор a, и соответствующий вектор keyvalues ключевых значений 
#элементов вектора a, осуществляющую сортировку вектора a по ключевым значениям его элементов, и возвращающую ссылку на вектор a.
#(Для сортировки вектора ключевых значений можно востпользоваться одной из разработанных в пункте 1 функций, или соответствующей встроенной 
#функцией).

#С использованием разработанной функции sortkey! написать функцию высшего порядка, с тем же именем sortkey!, но получающую на вход ключевую 
#функцию и массив элементов некоторого типа, на множестве значений которых должна быть определена данная ключевая функция.

#С использованием этой последней функции отсортировать столбцы какой-либо заданной числовой матрицы в порядке а) не убывания их сумм б) 
#не убывания числа нулей в них

function sort_key!(key_values,x)  #вектор, полученный сортировкой по индексам
    ind=sortperm!(key_values)
    return x[ind]   # A=[10,20,30] ind=[3,2,1] A[ind]=[30,20,10]
end

function sortperm!(key)   #функция сортировки индексов
    size=length(key)
    index=collect(1:size) #collect -создать массив со значениями от 1 до size  
    for i in 1 : size-1
        for j in i : size
            if key[i]>key[j]
                key[i],key[j]=key[j],key[i]   
                index[i],index[j]= index[j],index[i]      
            end
        end
    end
    return index  
end

sort_key!(f::Function,x)=sort_key!(f.(x),x)  #Передается любая функция. Функция высшего порядка 

sort_summ(x)=hcat(sort_key!(sum(x,dims=1),[@view x[:,j] for j in 1:size(x,2)])...)


function sort_zero(x)
    a = [@view x[:,j] for j in 1:size(x,2)]
    keyvalues = [length(findall(x[:,j] .== 0)) for j in 1:size(x,2)]
    B = hcat(sort_key!(keyvalues, a)...)
    return B
end

#Чтобы из  столбцов 
#получить матрицу, нужно выполнить операцию горизонтальной конкатенации отдельных столбцов. Для этого может
# быть использована встроенная функция vcat, аргументами кторорой должны быть столбцы матрицы. Чтобы извлечь 
#столбцы из содержащего их вектора использована операция "...".
#Функция vcat содержит один элемент, а нам необходимо несколько, поэтому происходит распаковка "разбиение на отдельные элементы "
#Если был кортеж,то вернет столбец vcat((2,3,4)...)-> [2,3,4]- в итоге столбец отдельных элементов 
#Распаковка осуществляюется путем операции "..."
#vcat-конкатенация по столбцам
#hcat-конкатенация по строкам 
#без ... sort_zero вернет 
 #=[2, 3, 0]
   [1, 0, 0]
   [0, 0, 0] =#
# то есть массив векторов, а надо каждый из них распаковать
#findall- вернет индекс элемента,для которого верно логическое условие (напр, сравнение элемента с каким-либо числом)
#length(findall.....)- показывает сколько существует индексов с нужным значением в столбце
# у нас сформируется список(кортеж) с индексами для каждого столбца и мы находим его длину
#это и будет наш ключ для сортировки
  

